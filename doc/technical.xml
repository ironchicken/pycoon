<?xml version="1.0" encoding="utf-8" ?>

<document>
  <head>
    <title>Pycoon White Paper</title>
    <author email="richardlewis@fastmail.co.uk">Richard Lewis</author>
    <date>2006-10-10</date>
  </head>
  <body>
    <div id="introduction" title="Introduction">
      <p>
	This white paper details the implementation of an XML web publishing framework written in
	the <link href="http://www.python.org/">Python</link> programming language, based on the
	concept of XML <link href="http://en.wikipedia.org/wiki/XML_pipeline">pipeline</link>
	processing and similar in intention to the <link href="http://cocoon.apache.org/">Apache
	Cocoon</link> project.
      </p>
      <p>
	There were two main reasons for my choosing to attempt to write an XML web publishing
	framework: first was that I was not happy with the Java-based approach used in Apache Cocoon
	and its reliance on a Java Servlet engine; and second was that I felt I would benefit from
	the technical challenge.
      </p>
    </div>
    <div id="aims" title="Project Aims">
      <p>
	The main aims of the Pycoon project are to implement an XML web publishing framework which:
	<list>
	  <item>
	    Feels very familiar to Cocoon users; uses the 'sitemap' concept and similarly named
	    components
	  </item>
	  <item>
	    Integrates well with the Apache web server
	  </item>
	  <item>
	    Allows experienced Python programmers to write their own components
	  </item>
	  <item>
	    Attempts to maintain a small code footprint and stays manageable
	  </item>
	  <item>
	    Is reasonably light on system resources
	  </item>
	</list>
      </p>
    </div>
    <div id="deployment" title="Deployment">
      <p>
	Pycoon is deployed as mod_python handler in Apache. It has been tested as a VirtualHost
	handler, though would probably work as a handler for the whole Apache server (at the expense
	of being able to do anything else with the server - including serving ordinary files!) and
	may work as a directory handler but it would be necessary to use the absolute URI path in
	matcher patterns.
      </p>
      <p>
	The required Apache VirtualHost configuration should follow this format:
      </p>
      <code xml:space="preserve">
&lt;VirtualHost *&gt;
    ServerName localhost
    DocumentRoot /var/www

    SetHandler mod_python
    PythonPath 'sys.path+["/var/www/"]'

    SetEnv PycoonConfigRoot /etc/pycoon
    SetEnv PycoonSitemap sitemap.xm

    PythonHandler pycoon
&lt;/VirtualHost&gt;
      </code>
      <p>
	The PycoonConfigRoot and PycoonSitemap variables are optional and the values shown above are
	also the default values. The PycoonConfigRoot directory should contain the server.xml file
	and the <path>resources</path> directory (see <path>conf</path> in the svn trunk).
      </p>
    </div>
    <div id="implementation" title="Implementation">
      <p>
	The two main tools which were assumed at the outset were the <link
	href="http://www.python.org/">Python</link> programming language and the <link
	href="http://httpd.apache.org/">Apache</link> web server. As a result of these decisions, it
	was logical to choose to use <link href="http://www.modpython.org/">mod_python</link> to
	link the two technologies.
      </p>
      <p>
	The concept of the 'sitemap' XML file for describing pipelines was taken from Cocoon and an
	attempt has been made to adopt a similar sitemap syntax in Pycoon.
      </p>
      <p>
	The component based architecture, as well as being a feature of Cocoon, is typical of many
	programming projects that aim towards extensibility. The classes of components implemented
	(including 'matchers', 'selectors', 'generators', 'transformers' and 'serializers') have
	been chosen for their familiarity to Cocoon users but they are also practical and
	descriptive names for the concepts they encapsulate.
      </p>
      <p>
	Where Cocoon handles XML data as SAX events through its pipelines, Pycoon uses the <link
	href="http://http://effbot.org/zone/element-index.htm">ElementTree</link> interface to store
	the current state of the XML pipeline and manipulate it at each stage. This may be a less
	efficient method than SAX event streams but it does have the advantage of allowing for much
	simpler code. It is easier to construct and manipulate ElementTree data in Python than it is
	to construct and manipulate SAX events.
      </p>
      <div id="class-hierarchy" title="Component Class Hierarchy">
	<p>
	  This diagram shows the component hierarchy and all the currently implemented components:
	</p>
	<class-hierarchy>
	<class name="component" description="Component base class">
	  <class name="pipeline" description="The container class for components which provides 'execution' methods" />
	  <class name="syntax_component" description="Base class of all components which handle logical processing in sitemaps">
	    <class name="matcher" description="Matcher base class">
	      <class name="uri_matcher" description="Allows pipeline processing to be conditional on URI patterns" />
	      <class name="error_matcher" description="Allows pipeline processing to be conditional on HTTP error conditions" />
	    </class>
	    <class name="selector" description="Selector base class">
	      <class name="browser_class_selector" description="Allows pipeline processing to be conditional on the type of browser the client is using [graphic|text|aural|braille]" />
	      <class name="browser_selector" description="Allows pipeline processing to be conditional the name of the browser the client is using" />
	      <class name="request_parameter_selector" description="Allows pipeline processing to be conditional on the value of a request parameter (either GET or POST)" />
	      <class name="resource_exists_selector" description="Allows pipeline processing to be conditional on the existence of a file" />
	    </class>
	    <class name="parameter" description="Used to pass parameters to any components which require them" />
	    <class name="when" description="Used to implement the conditions of selector components" />
	    <class name="otherwise" description="Used to implement the default condition of selector components" />
	  </class>
	  <class name="stream_component" description="Base class for all components which handle XML data in a pipeline">
	    <class name="generator" description="Generator base class">
	      <class name="xml_generator" description="Use an XML file to provide the source XML for a pipeline" />
	      <class name="http_generator" description="Retrieve the source XML for a pipeline using an HTTP request" />
	      <class name="xpath_generator" description="Execute an XPath expression against an XML file to provide the source XML for a pipeline" />
	      <class name="aggregate_generator" description="The child generators' results are aggregated to provide the source XML for a pipeline" />
	      <class name="command_generator" description="The stdout stream from a shell command provides the source XML for a pipeline" />
	      <class name="directory_generator" description="Converts a directory listing into the source XML for a pipeline" />
	      <class name="xquery_generator" description="Execute an XQuery expression against an XML database (Berkelely DB XML) to provide the source XML for a pipeline" />
	      <class name="sql_generator" description="Execute an SQL query against a database to provide the source XML for a pipeline" />
	      <class name="swishe_generator" description="Execute a full-text search against a Swish-e index to provide the source XML for a pipeline" />
	    </class>
	    <class name="transformer" description="Transformer base class">
	      <class name="xslt_transformer" description="Transform the pipeline XML stream using an XSLT stylesheet" />
	      <class name="command_transformer" description="Transform the pipeline XML stream using a shell command" />
	      <class name="sax_handler_transformer" description="Transform the pipeline XML stream using a Python SAX handler class" />
	    </class>
	    <class name="serializer" description="Serializer base class">
	      <class name="html_serializer" description="Convert the pipeline XML stream into an HTML document" />
	      <class name="xhtml_serializer" description="Convert the pipeline XML stream into an XHTML document" />
	      <class name="xml_serializer" description="Convert the pipeline XML stream into an XML document" />
	      <class name="pdf_serializer" description="Convert the pipeline XML stream (which must contain XSL-FO) into a PDF document (NOT IMPLEMENTED)" />
	      <class name="svg_serializer" description="Convert the pipeline XML stream (which must contain SVG) into an image (PARTIAL IMPLEMENTATION)" />
	    </class>
	  </class>
	</class>
      </class-hierarchy>
      </div>
      <div id="class-descriptions" title="Class Descriptions">
	<class name="component">
	  <name>component</name>
	  <source>pycoon/components.py</source>
	  <description>
	    The component class is the base class of all pipeline components in Pycoon.
	  </description>
	  <method name="__init__">
	    <definition>__init__(self, parent, root_path="")</definition>
	    <description>
	      <p>
		Class constructor. <identifier>parent</identifier> is the component's parent in the
		pipeline and may be another component or a <link class="pipeline">pipeline</link> or
		<link class="sitemap">sitemap</link> object. <identifier>root_path</identifier> is a
		base path which derived components should use to resolve path names; it is an
		optional parameter and takes the value of the parent sitemap (or server) document
		root if not specified.
	      </p>
	    </description>
	  </method>
	  <method name="__call__">
	    <definition>__call__(self, req, p_sibling_result=None, child_results=[])</definition>
	    <returns>
	      Returns a tuple whose first member is a boolean flag indicating whether the execution
	      was successful or not and whose second member is the <identifier>Element</identifier>
	      result.
	    </returns>
	    <description>
	      <p>
		Main execution method. <identifier>req</identifier> is an Apache request
		object. <identifier>p_sibling_result</identifier> is the
		<identifier>Element</identifier> returned by the previous sibling component in the
		pipeline.  <identifier>child_results</identifier> is a list of the
		<identifier>Element</identifier> results of all the child componets which have been
		executed so far.
	      </p>
	      <p>
		This method first calls the object's <link class="component"
		method="_descend">_descend</link> method and, if it returns
		<identifier>True</identifier>, it loops over the component's child components and
		calls each one's __call__ method, passing the previous child's result as the
		<identifier>p_sibling_result</identifier> each time.
	      </p>
	    </description>
	  </method>
	  <method name="_descend">
	    <definition>_descend(self, req, p_sibling_result=None)</definition>
	    <returns>
	      Returns a boolean.
	    </returns>
	    <description>
	      <p>
		<identifier>req</identifier> is an Apache request
		object. <identifier>p_sibling_result</identifier> is the
		<identifier>Element</identifier> returned by the previous sibling component in the
		pipeline.
	      </p>
	      <p>
		The _descend method allows derived components to give permission for their child
		components to be executed or not. It is passed the current query context (the
		request object) and the result of its previous sibling which implementations can use
		to determine the return value. Its default behaviour is simply to return
		True. However, components such as <link class="matcher">matchers</link> and <link
		class="selector">selectors</link> need to override this method.
	      </p>
	    </description>
	  </method>
	  <method name="_continue">
	    <definition>_continue(self, req, p_sibling_result=None)</definition>
	    <returns>
	      Returns a boolean.
	    </returns>
	    <description>
	      <p>
		<identifier>req</identifier> is an Apache request
		object. <identifier>p_sibling_result</identifier> is the
		<identifier>Element</identifier> returned by the previous sibling component in the
		pipeline.
	      </p>
	      <p>
		The _continue method is similar to the <link class="component"
		method="_descend">_descend</link> method: it allows derived components to give
		permission for their following sibling components to be executed or not. It is
		passed the current query context (the request object) and the result of its previous
		sibling which implementations can use to determine the return value. Its default
		behaviour is simply to return True. However, components such as the <link
		class="when">when</link> component need to override this method and the <link
		class="uri_matcher">uri_matcher</link> overrides it to improve efficientcy (once a
		matching URI pattern has been found and its components executed, no further pipeline
		processing is carried out).
	      </p>
	    </description>
	  </method>
	  <method name="_result">
	    <definition>_result(self, req, p_sibling_result=None, child_results=[])</definition>
	    <returns>
	      Returns a tuple whose first member is a boolean flag indicating whether the execution
	      was successful or not and whose second member is the <identifier>Element</identifier>
	      result.
	    </returns>
	    <description>
	      <p>
		XML data handling components should do their main work in this
		method. <identifier>req</identifier> is an Apache request
		object. <identifier>p_sibling_result</identifier> is the
		<identifier>Element</identifier> returned by the previous sibling component in the
		pipeline. <identifier>child_results</identifier> is a list of the
		<identifier>Element</identifier> results of all this component's child componets.
	      </p>
	      <p>
		The default implementation raises a <identifier>NotImplemented</identifier>
		exception. All derived components should perform their main function in this method
		(or at least from this method) and return a tuple whose first member is a boolean
		indicating whether or not they were successful and whose second member, on success,
		should be an <identifier>Element</identifier> object, or, on failure, an Apache
		error code. (Note, however, that exceptions will be handled gracefully by Pycoon and
		result in a descriptive HTTP 500 error.)
	      </p>
	    </description>
	  </method>
	  <method name="add_component">
	    <definition>add_component(self, c, pos=None)</definition>
	    <returns>
	      The added component
	    </returns>
	    <description>
	      <p>
		Add a child component. <identifier>c</identifier> is a component
		object. <identifier>pos</identifier> is the position, expressed as a number, at
		which the component should be added; by default the component is appended as the
		last child component.
	      </p>
	    </description>
	  </method>
	  <method name="parameter_children">
	    <definition>parameter_children(self, child_results)</definition>
	    <returns>
	      A dictionary
	    </returns>
	    <description>
	      <p>
		Converts <link class="parameter">parameter</link> child components into a dictionary
		of name/value pairs. <identifier>child_results</identifier> is a list of parameter
		components.  (Note: the current implementation of this function is quite naive in
		that it performs inadequate type checking on the given child_results and relies on
		sitemap class's syntax checking to make sure that child components will actually be
		parameters).
	      </p>
	    </description>
	  </method>
	  <method name="find_components">
	    <definition>find_components(self, class_name, found=[])</definition>
	    <returns>
	      A list of components (may be empty)
	    </returns>
	    <description>
	      <p>
		Searches all of this component's child components and returns any whose class name
		matches the given <identifier>class_name</identifier>. It is a recursive function so
		the <identifier>found</identifier> parameter is simply the list of matching
		components found by the previous call.
	      </p>
	      <p>
		This function is most effectively used by the <link class="pipeline">pipeline</link>
		component as it has the most children. It is used by the pipeline component's <link
		class="pipeline" method="handle_error">handle_error</link> method to find available
		<link class="error_matcher">error_matcher</link> components.
	      </p>
	    </description>
	  </method>
	  <property>
	    <name>parent</name>
	    <description>
	      The parent component of this component.
	    </description>
	  </property>
	  <property>
	    <name>sitemap</name>
	    <description>
	      The parent sitemap of this component.
	    </description>
	  </property>
	  <property>
	    <name>server</name>
	    <description>
	      The parent server of this component.
	    </description>
	  </property>
	  <property>
	    <name>context</name>
	    <description>
	      Either a reference to the compoent's parent sitemap or, if this is None, the
	      component's parent server.
	    </description>
	  </property>
	  <property>
	    <name>root_path</name>
	    <description>
	      The base path which should be prefixed to any filenames used by the component. By
	      default, it takes either the sitemap or server's document root.
	    </description>
	  </property>
	  <property>
	    <name>children</name>
	    <description>
	      A list of child components.
	    </description>
	  </property>
	  <property>
	    <name>description</name>
	    <description>
	      A short string describing the component. In derived components, the parameters (such
	      as URI pattern) are added to this description to improve debugging information.
	    </description>
	  </property>
	  <class-property>
	    <name>role</name>
	    <description>
	      Should be either "stream" or "syntax". For component class the value is "none".
	    </description>
	  </class-property>
	  <class-property>
	    <name>function</name>
	    <description>
	      Should be one of "matcher", "selector", "generator", "transformer", "serializer", etc.
	      For component class the value is "none".
	    </description>
	  </class-property>
	  <helper-func name="register_component">
	    <definition>register_component(server, super_type, attrs)</definition>
	    <description>
	      <p>
		Loads a component class for later use by sitemaps. <identifier>server</identifier>
		is the server object; <identifier>super_type</identifier> is one of "matcher",
		"generator", "transformer", etc.; <identifier>attrs</identifier> is an
		<identifier>xml.sax.xmlreader.AttributesImpl</identifier> which contains the
		attributes supplied by the server configuration file for the component (normally
		"name", "module" and "class").
	      </p>
	    </description>
	  </helper-func>
	</class>
	<class name="invokation_syntax">
	  <name>invokation_syntax</name>
	  <source>pycoon/components.py</source>
	  <description>
	    Used to store the XML syntax rules for how a component should be used in a sitemap file.
	  </description>
	  <method name="__init__">
	    <definition>__init__(self)</definition>
	    <description>
	      <p>
		Class constructor. Creates empty instance properties.
	      </p>
	    </description>
	  </method>
	  <method name="validate">
	    <definition>validate(self, parent_name, name, attrs)</definition>
	    <returns>
	      Returns a boolean
	    </returns>
	    <description>
	      <p>
		Checks the given XML element attributes for
		validity. <identifier>parent_name</identifier> is the element name of the parent
		component; <identifier>name</identifier> is the element name of the element being
		checked; <identifier>attrs</identifier> is an
		<identifier>xml.sax.xmlreader.AttributesImpl</identifier> instance from the sitemap
		element being checked.
	      </p>
	      <p>
		The method raises exceptions on any syntax errors in the component usage. If there are
		no errors it returns True.
	      </p>
	    </description>
	  </method>
	  <property>
	    <name>element_name</name>
	    <description>
	      The required element name for the component.
	    </description>
	  </property>
	  <property>
	    <name>allowed_parent_components</name>
	    <description>
	      A list of the element names of components of the components of which this component
	      may be a child.
	    </description>
	  </property>
	  <property>
	    <name>required_attribs</name>
	    <description>
	      A list of the names of required XML attributes for the component.
	    </description>
	  </property>
	  <property>
	    <name>required_attrib_values</name>
	    <description>
	      A dictionary of name/value pairs of the required values of XML attributes of the component.
	    </description>
	  </property>
	  <property>
	    <name>optional_attribs</name>
	    <description>
	      A list of the names of optional XML attributes for the component.
	    </description>
	  </property>
	  <property>
	    <name>allowed_child_components</name>
	    <description>
	      A list of the element names of components which are allowed to be child components of
	      this component.
	    </description>
	  </property>
	</class>
	<class name="syntax_component">
	  <name>syntax_component</name>
	  <inherits>component</inherits>
	  <source>pycoon/components.py</source>
	  <description>
	    Base class of all components which handle logical processing in sitemaps.
	  </description>
	  <class-property>
	    <name>role</name>
	    <description>
	      For syntax_component class the value is "syntax".
	    </description>
	  </class-property>
	  <method name="_result">
	    <definition>_result(self, req, p_sibling_result=None, child_results=[])</definition>
	    <overrides><link class="component" method="_result">component._result</link></overrides>
	    <returns>
	      Returns a tuple whose first member is a boolean flag indicating whether the execution
	      was successful or not and whose second member is the <identifier>Element</identifier>
	      result.
	    </returns>
	    <description>
	      <p>
		This default implementation for syntax components simply either returns the last
		<identifier>child_results</identifier> <identifier>Element</identifier> (if there is
		one) or the <identifier>p_sibling_result</identifier> along with a True success
		flag.
	      </p>
	    </description>
	  </method>
	</class>
	<class name="stream_component">
	  <name>stream_component</name>
	  <inherits>component</inherits>
	  <source>pycoon/components.py</source>
	  <description>
	    Base class for all components which handle XML data in a pipeline.
	  </description>
	  <class-property>
	    <name>role</name>
	    <description>
	      For stream_component class the value is "stream".
	    </description>
	  </class-property>
	</class>
	<class name="pipeline">
	  <name>pipeline</name>
	  <inherits>component</inherits>
	  <source>pycoon/pipeline.py</source>
	  <description>
	    The container class for components which provides 'execution' methods for pipeline
	    processing.
	  </description>
	  <syntax xml:space="preserve">
&lt;!ELEMENT pipeline (match+)&gt;
	  </syntax>
	  <method name="__init__">
	    <definition>__init__(self, parent, cache_as="")</definition>
	    <overrides><link class="component" method="__init__">component.__init__</link></overrides>
	    <description>
	      <p>
		Class constructor. <identifier>cache_as</identifier> is currently not used.
	      </p>
	      <p>
		The method just calls <link class="component" method="__init__">component.__init__</link>
		and sets its <identifier>description</identifier> property to "Pipeline".
	      </p>
	    </description>
	  </method>
	  <method name="force_execute">
	    <definition>force_execute(self, output, uri)</definition>
	    <returns>
	      Returns a 3-tuple which consists of: a boolean flag indicating whether the execution
	      was successful or not; the result of the execution which is either a character stream
	      or an HTTP error code; the MIME type of the result.
	    </returns>
	    <description>
	      <p>
		Allows a pipeline to be executed without an Apache request object and without
		returning the result to the client. <identifier>output</identifier> is a file-like
		object and <identifier>uri</identifier> is a request URI string.
	      </p>
	      <p>
		This method creates a fake request object using the give file-like object and URI
		string and then calls the <link class="pipeline" method="execute">execute</link>
		using this object (rather than a real Apache request object). The result of the
		execution will be written to the given file-like object and <em>not</em> returned to
		the client.  It is used by the <link class="interpolate_context"
		method="__call__">context</link> interpolation method.
	      </p>
	    </description>
	  </method>
	  <method name="_descend">
	    <definition>_descend(self, req, p_sibling_result=None)</definition>
	    <overrides><link class="component" method="_descend">component._descend</link></overrides>
	    <returns>
	      Returns a boolean.
	    </returns>
	    <description>
	      <p>
		Returns True so that child components of the pipeline will be executed.
	      </p>
	    </description>
	  </method>
	  <method name="_result">
	    <definition>_result(self, req, p_sibling_result=None, child_results=[])</definition>
	    <overrides><link class="component" method="_result">component._result</link></overrides>
	    <returns>
	      Returns a tuple whose first member is a boolean flag indicating whether the execution
	      was successful or not and whose second member is the <identifier>Element</identifier>
	      result.
	    </returns>
	    <description>
	      <p>
		This default implementation for pipelines simply either returns the last
		<identifier>child_results</identifier> <identifier>Element</identifier> (if there is
		one) or None.
	      </p>
	    </description>
	  </method>
	  <method name="execute">
	    <definition>execute(self, req)</definition>
	    <returns>
	      Returns a 3-tuple which consists of: a boolean flag indicating whether the execution
	      was successful or not; the result of the execution which is either a character stream
	      or an HTTP error code; the MIME type of the result.
	    </returns>
	    <description>
	      <p>
		Executes the pipeline. <identifier>req</identifier> is an Apache request object.
	      </p>
	      <p>
		This method calls the object's inherited <link class="component"
		method="__call__">__call__</link> method, extracts the success flag, result stream
		and MIME type from the return value and returns all three as a tuple. It catches any
		exceptions raised during the execution, stores the traceback in a global location
		and returns a False success flag and an HTTP 500 error.
	      </p>
	    </description>
	  </method>
	  <method name="handle_error">
	    <definition>handle_error(self, req)</definition>
	    <returns>
	      Returns a 3-tuple which consists of: a boolean flag indicating whether the execution
	      was successful or not; the result of the execution which is either a character stream
	      or an HTTP error code; the MIME type of the result.
	    </returns>
	    <description>
	      <p>
		Executes the pipeline but only using its <link
		class="error_matcher">error_matcher</link> components. <identifier>req</identifier>
		is an Apache request object whose <identifier>status</identifier> property should
		contain the HTTP error code being handled.
	      </p>
	      <p>
		This method uses the <link class="component"
		method="find_components">component.find_components</link> method to search for all
		<link class="error_matcher">error_matcher</link> components. It executes the first
		one which can handle the error code in the given Request object's
		<identifier>status</identifier> property.  When an error_matcher is executed, it
		will return a tuple whose first member is a 'success' flag which is True if the
		execution was successful (and therefore the error has been handled) or False
		otherwise. If the method either could not find a suitable error_matcher or if an
		error_matcher returned False, it will return False and the error will not have been
		handled (further error handling in the sitemap or server will then apply).
	      </p>
	    </description>
	  </method>
	  <class-property>
	    <name>role</name>
	    <description>
	      Value is "pipeline".
	    </description>
	  </class-property>
	  <class-property>
	    <name>function</name>
	    <description>
	      Value is "pipeline".
	    </description>
	  </class-property>
	  <notes>
	  </notes>
	  <helper-func name="register_invokation_syntax">
	    <definition>register_invokation_syntax(server)</definition>
	    <description>
	      <p>
		This function creates and populates an instance of the <link
		class="invokation_syntax">invokation_syntax</link> class with the syntax for
		pipeline elements. This instance is then stored in the given server object's <link
		class="server_config" property="component_syntaxes">component_syntaxes</link>
		dictionary.
	      </p>
	    </description>
	  </helper-func>
	  <helper-func name="build_pipeline">
	    <definition>build_pipeline(server, sitemap, attrs, **kw_args)</definition>
	    <returns>
	      A pipeline object.
	    </returns>
	    <description>
	      <p>
		This function creates a new pipeline object from the given
		<identifier>xml.sax.xmlreader.AttributesImpl</identifier> object (in fact, at
		present pipeline elements use no attributes). If the pipeline is a sitemap pipeline
		(the ordinary case) the parent <identifier>server</identifier> and
		<identifier>sitemap</identifier> objects should be specified and the new pipeline
		will be added to the sitemap's <link class="sitemap_config"
		property="pipelines">pipelines</link> list. If the given
		<identifier>sitemap</identifier> is None, then the new pipeline is added to the
		server's <link class="server_config" property="pipelines">pipelines</link> list.
	      </p>
	      <p>
		The new pipeline object is returned.
	      </p>
	    </description>
	  </helper-func>
	</class>
	<class name="generator">
	  <name>generator</name>
	  <inherits>stream_component</inherits>
	  <source>pycoon/generators/__init__.py</source>
	  <description>
	    Base class for all generator components.
	  </description>
	  <syntax xml:space="preserve">
&lt;!ELEMENT match (generate?,...)&gt;
&lt;!ELEMENT when (generate?,...)&gt;
&lt;!ELEMENT otherwise (generate?,...)&gt;
&lt;!ELEMENT aggregate (generate+)&gt;
&lt;!ELEMENT generate (parameter*)&gt;
&lt;!ATTLIST generate type CDATA #REQUIRED&gt;
	  </syntax>
	  <method name="__init__">
	    <definition>__init__(self, parent, root_path="")</definition>
	    <overrides><link class="stream_component" method="__init__">stream_component.__init__</link></overrides>
	    <description>
	      <p>
		Just calls stream_component's <link class="stream_component"
		method="__init__">__init__</link> method and sets
		<identifier>description</identifier> property to "Generator base class".
	      </p>
	    </description>
	  </method>
	  <class-property>
	    <name>role</name>
	    <description>
	      Value is "stream".
	    </description>
	  </class-property>
	  <class-property>
	    <name>function</name>
	    <description>
	      Value is "generate".
	    </description>
	  </class-property>
	  <helper-func name="register_invokation_syntax">
	    <definition>register_invokation_syntax(server)</definition>
	    <description>
	      <p>
		This function creates and populates an instance of the <link
		class="invokation_syntax">invokation_syntax</link> class with an abstract syntax for
		generator elements. This instance is then stored in the given server object's <link
		class="server_config" property="component_syntaxes">component_syntaxes</link>
		dictionary.
	      </p>
	    </description>
	  </helper-func>
	</class>
	<class name="transformer">
	  <name>transformer</name>
	  <inherits>stream_component</inherits>
	  <source>pycoon/transformers/__init__.py</source>
	  <description>
	    Base class for all transformer components.
	  </description>
	  <syntax xml:space="preserve">
&lt;!ELEMENT match (transform?,...)&gt;
&lt;!ELEMENT when (transform?,...)&gt;
&lt;!ELEMENT otherwise (transform?,...)&gt;
&lt;!ELEMENT transform (parameter*)&gt;
&lt;!ATTLIST transform type CDATA #REQUIRED&gt;
	  </syntax>
	  <method name="__init__">
	    <definition>__init__(self, parent, root_path="")</definition>
	    <overrides><link class="stream_component" method="__init__">stream_component.__init__</link></overrides>
	    <description>
	      <p>
		Just calls stream_component's <link class="stream_component"
		method="__init__">__init__</link> method and sets
		<identifier>description</identifier> property to "Transformer base class".
	      </p>
	    </description>
	  </method>
	  <class-property>
	    <name>role</name>
	    <description>
	      Value is "stream".
	    </description>
	  </class-property>
	  <class-property>
	    <name>function</name>
	    <description>
	      Value is "transform".
	    </description>
	  </class-property>
	  <helper-func name="register_invokation_syntax">
	    <definition>register_invokation_syntax(server)</definition>
	    <description>
	      <p>
		This function creates and populates an instance of the <link
		class="invokation_syntax">invokation_syntax</link> class with an abstract syntax for
		transformer elements. This instance is then stored in the given server object's <link
		class="server_config" property="component_syntaxes">component_syntaxes</link>
		dictionary.
	      </p>
	    </description>
	  </helper-func>
	</class>
	<class name="serializer">
	  <name>serializer</name>
	  <inherits>stream_component</inherits>
	  <source>pycoon/serializers/__init__.py</source>
	  <description>
	    Base class for all serializer components.
	  </description>
	  <syntax xml:space="preserve">
&lt;!ELEMENT match (serialize?,...)&gt;
&lt;!ELEMENT when (serialize?,...)&gt;
&lt;!ELEMENT otherwise (serialize?,...)&gt;
&lt;!ELEMENT serialize&gt;
&lt;!ATTLIST serialize type CDATA #REQUIRED&gt;
&lt;!ATTLIST serialize mime CDATA #IMPLIED&gt;
	  </syntax>
	  <method name="__init__">
	    <definition>__init__(self, parent, root_path="")</definition>
	    <overrides><link class="stream_component" method="__init__">stream_component.__init__</link></overrides>
	    <description>
	      <p>
		Just calls stream_component's <link class="stream_component"
		method="__init__">__init__</link> method and sets
		<identifier>description</identifier> property to "Serializer base class".
	      </p>
	    </description>
	  </method>
	  <class-property>
	    <name>role</name>
	    <description>
	      Value is "stream".
	    </description>
	  </class-property>
	  <class-property>
	    <name>function</name>
	    <description>
	      Value is "serialize".
	    </description>
	  </class-property>
	  <helper-func name="register_invokation_syntax">
	    <definition>register_invokation_syntax(server)</definition>
	    <description>
	      <p>
		This function creates and populates an instance of the <link
		class="invokation_syntax">invokation_syntax</link> class with an abstract syntax for
		serializer elements. This instance is then stored in the given server object's <link
		class="server_config" property="component_syntaxes">component_syntaxes</link>
		dictionary.
	      </p>
	    </description>
	  </helper-func>
	</class>
	<class name="">
	  <name></name>
	  <inherits></inherits>
	  <source></source>
	  <description>
	  </description>
	  <syntax>
	  </syntax>
	  <notes>
	  </notes>
	</class>
	<class name="">
	  <name></name>
	  <inherits></inherits>
	  <source></source>
	  <description>
	  </description>
	  <syntax>
	  </syntax>
	  <notes>
	  </notes>
	</class>


	<class name="">
	  <name></name>
	  <inherits></inherits>
	  <source></source>
	  <description>
	  </description>
	  <syntax>
	  </syntax>
	  <notes>
	  </notes>
	</class>
      </div>
    </div>
  </body>
</document>
